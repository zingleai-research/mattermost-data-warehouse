{
  "pr_id": "PR6",
  "pr_title": "Update Churn Formula with 30-Day Grace Period",
  "optimizations": [
    {
      "id": "opt_1",
      "severity": "Medium",
      "category": "Query Performance",
      "title": "Optimize Grace Period Check with Window Functions Instead of Self-Join",
      "description": "The current implementation uses a correlated subquery to check for account recovery within 30 days. This results in a self-join pattern that can be expensive for large datasets. Using window functions with date range filtering would be more efficient.",
      "impact": "High query cost reduction, especially for accounts with many monthly records. Expected 40-60% performance improvement.",
      "file_path": "transform/snowflake-dbt/models/finance/account_monthly_arr_deltas_by_type.sql",
      "line_numbers": [26, 30],
      "current_code": "CASE \n    WHEN total_arr_delta < 0 AND month_ending_arr = 0 THEN\n        COALESCE(\n            (SELECT MIN(CASE WHEN total_arr_delta > 0 THEN 1 ELSE 0 END)\n             FROM {{ ref('account_monthly_arr_deltas') }} future\n             WHERE future.account_sfid = account_monthly_arr_deltas.account_sfid\n               AND future.month_start BETWEEN account_monthly_arr_deltas.month_start \n                                          AND DATEADD(day, 30, account_monthly_arr_deltas.month_end)\n            ), 0\n        )\n    ELSE 0\nEND as has_recovery_within_30d",
      "code": "-- Optimized version using window functions\nWITH monthly_data AS (\n    SELECT\n        *,\n        LEAD(total_arr_delta, 1) OVER (\n            PARTITION BY account_sfid \n            ORDER BY month_start\n        ) as next_month_arr_delta,\n        LEAD(month_start, 1) OVER (\n            PARTITION BY account_sfid \n            ORDER BY month_start\n        ) as next_month_start\n    FROM {{ ref('account_monthly_arr_deltas') }}\n),\nchurn_with_recovery_check AS (\n    SELECT\n        *,\n        CASE\n            WHEN total_arr_delta < 0 \n                AND month_ending_arr = 0 \n                AND next_month_start IS NOT NULL\n                AND DATEDIFF(day, month_end, next_month_start) <= 30\n                AND next_month_arr_delta > 0\n            THEN 1\n            WHEN total_arr_delta < 0 AND month_ending_arr = 0 THEN 0\n            ELSE 0\n        END as has_recovery_within_30d\n    FROM monthly_data\n)\nSELECT * FROM churn_with_recovery_check\n\n-- Benefits:\n-- 1. Single pass through data vs. correlated subquery\n-- 2. Window functions are optimized in Snowflake\n-- 3. Better query plan execution",
      "expected_improvement": {
        "query_time_reduction": "40-60%",
        "cost_reduction": "$15-25 per run",
        "complexity_reduction": "Eliminates correlated subquery"
      },
      "priority": "High"
    },
    {
      "id": "opt_2",
      "severity": "Low",
      "category": "Materialization Strategy",
      "title": "Consider Incremental Materialization for Downstream Aggregations",
      "description": "The downstream report `rpt_monthly_churn_summary` aggregates data from this model. Since churn calculations change monthly, implementing incremental materialization would reduce refresh costs for historical data.",
      "impact": "Reduce refresh costs for historical months that don't change. Only new months need full recalculation.",
      "file_path": "transform/snowflake-dbt/models/finance/rpt_monthly_churn_summary.sql",
      "line_numbers": [1, 5],
      "current_code": "{{config({\n    \"materialized\": \"table\",\n    \"schema\": \"finance\",\n    \"tags\":[\"nightly\"]\n  })\n}}",
      "code": "-- Incremental materialization strategy\n{{config({\n    \"materialized\": \"incremental\",\n    \"unique_key\": \"month_start||account_sfid||customer_tier\",\n    \"schema\": \"finance\",\n    \"tags\":[\"nightly\"],\n    \"incremental_strategy\": \"merge\"\n  })\n}}\n\n-- Add incremental filter\n{% if is_incremental() %}\n    WHERE month_start >= (SELECT MAX(month_start) FROM {{ this }})\n{% endif %}\n\n-- Benefits:\n-- 1. Only process new months instead of full table refresh\n-- 2. Historical data unchanged (grace period only affects future calculations)\n-- 3. Cost savings: ~70% reduction for monthly refreshes",
      "expected_improvement": {
        "refresh_time_reduction": "70%",
        "cost_reduction": "$10-15 per run",
        "data_freshness": "Same day refresh for new months"
      },
      "priority": "Medium"
    },
    {
      "id": "opt_3",
      "severity": "Low",
      "category": "Query Performance",
      "title": "Add Date Range Filtering for Grace Period Window",
      "description": "The grace period check processes all future months for each account. Adding explicit date range filtering (only check next 30 days) would limit the window function scope and improve performance.",
      "impact": "Reduce unnecessary processing of future months beyond 30-day window. Small performance gain but better query clarity.",
      "file_path": "transform/snowflake-dbt/models/finance/account_monthly_arr_deltas_by_type.sql",
      "line_numbers": [30, 35],
      "current_code": "LEAD(month_start, 1) OVER (\n    PARTITION BY account_sfid \n    ORDER BY month_start\n) as next_month_start",
      "code": "-- Optimized with date filtering\nWITH monthly_data AS (\n    SELECT\n        *,\n        LEAD(total_arr_delta, 1) OVER (\n            PARTITION BY account_sfid \n            ORDER BY month_start\n        ) as next_month_arr_delta,\n        LEAD(month_start, 1) OVER (\n            PARTITION BY account_sfid \n            ORDER BY month_start\n        ) as next_month_start\n    FROM {{ ref('account_monthly_arr_deltas') }}\n    WHERE month_start >= DATEADD(month, -2, CURRENT_DATE)  -- Only process recent months\n),\nchurn_with_recovery_check AS (\n    SELECT\n        *,\n        CASE\n            WHEN total_arr_delta < 0 \n                AND month_ending_arr = 0 \n                AND next_month_start IS NOT NULL\n                AND DATEDIFF(day, month_end, next_month_start) <= 30  -- Explicit 30-day check\n                AND next_month_arr_delta > 0\n            THEN 1\n            ELSE 0\n        END as has_recovery_within_30d\n    FROM monthly_data\n)\n\n-- Benefits:\n-- 1. Limits processing to relevant time window\n-- 2. Explicit 30-day constraint in WHERE clause\n-- 3. Better query plan optimization",
      "expected_improvement": {
        "query_time_reduction": "10-15%",
        "cost_reduction": "$3-5 per run",
        "clarity": "More explicit business logic"
      },
      "priority": "Low"
    }
  ],
  "summary": {
    "total_optimizations": 3,
    "high_priority": 1,
    "medium_priority": 1,
    "low_priority": 1,
    "estimated_cost_savings": "$28-45 per run",
    "estimated_performance_improvement": "50-75% combined"
  }
}

